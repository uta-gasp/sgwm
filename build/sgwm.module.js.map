{"version":3,"sources":["webpack:///webpack/bootstrap 74e564aed31873e89abd","webpack:///./sgwm.js","webpack:///./fixationProcessor.js","webpack:///./fixationProcessorSettings.js","webpack:///./settings.js","webpack:///./splitToProgressions.js","webpack:///./splitToProgressionsSettings.js","webpack:///./textModel.js","webpack:///./progressionMerger.js","webpack:///./regression.js","webpack:///./progressionMergerSettings.js","webpack:///./wordMapper.js","webpack:///./wordMapperSettings.js"],"names":[],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA4B;AAC5B;AACA,yBAAwB;AACxB,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,qEAAoE,QAAQ;;AAE5E;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,cAAa;AACb;;AAEA,6CAA4C,kCAAkC;AAC9E,6CAA4C,kCAAkC;AAC9E,+CAA8C,oCAAoC;AAClF,sCAAqC,2BAA2B;AAChE;;AAEA,uB;;;;;;AC9DA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,oBAAmB;;AAEnB;AACA;AACA,mBAAkB,WAAW;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,sBAAsB;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;ACpJA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAiB,uBAAuB;AACxC,yBAAwB,wBAAwB;AAChD,kBAAiB,uBAAuB;AACxC,yBAAwB,wBAAwB;AAChD;;AAEA,4C;;;;;;AC5BA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2B;;;;;;AC3CA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,G;;;;;;ACpDA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gBAAe,qBAAqB;AACpC,uBAAsB,sBAAsB;AAC5C,eAAc,oBAAoB;AAClC,sBAAqB,qBAAqB;;AAE1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8C;;;;;;ACtCA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAsB,kEAAkE;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAuB,kBAAkB;AACzC,2CAA0C;AAC1C;;AAEA;AACA,qCAAoC,mBAAmB;AACvD,oCAAmC,kBAAkB;AACrD,mDAAkD,iCAAiC;AACnF,qDAAoD,mCAAmC;;AAEvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAY,kBAAkB;AAC9B,eAAc,oBAAoB;AAClC,kBAAiB,oBAAoB;AACrC,oBAAmB,yBAAyB;AAC5C,8BAA6B,gCAAgC;AAC7D;;AAEA;AACA;AACA;AACA;AACA,wBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,iBAAiB;AACpC;AACA;AACA,oBAAmB,kBAAkB;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;;AAEL;AACA;;AAEA,4B;;;;;;AC/GA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAmB;;AAEnB;AACA;AACA;AACA,mBAAkB,WAAW;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,oBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;;AAEA;AACA,wBAAuB,0BAA0B;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT,MAAK;AACL;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA,oBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA2B,OAAO;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAoC,cAAc,MAAM,cAAc;AACtE;;AAEA,wBAAuB,sBAAsB;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAuC,eAAe,EAAE;AACxD,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oC;;;;;;AChZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;AAEA;AACA;AACA,uBAAsB,OAAO;AAC7B;AACA,8BAA6B,OAAO;AACpC;AACA;AACA;AACA,0BAAyB,WAAW;AACpC;AACA;AACA;AACA;AACA,8BAA6B,OAAO;AACpC,6BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA,2BAA0B,QAAQ;AAClC;AACA,8BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+CAA8C,SAAS;AACvD;AACA;AACA;;AAEA;;AAEA,qBAAoB;AACpB,UAAS;;AAET;AACA;;AAEA,mBAAkB,iBAAiB;AACnC;AACA,uDAAsD;AACtD,uDAAsD;AACtD;AACA;;AAEA;;AAEA,+CAA8C,SAAS;AACvD;AACA;AACA;;AAEA;;AAEA,qBAAoB;AACpB,UAAS;;AAET;AACA;;AAEA,oCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+CAA8C,SAAS;AACvD;AACA;AACA;;AAEA;;AAEA,qBAAoB;AACpB,UAAS;;AAET;AACA;;AAEA,oCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+CAA8C,SAAS;AACvD;AACA;AACA;;AAEA;;AAEA,qBAAoB;AACpB,UAAS;;AAET;AACA;;AAEA,oCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+CAA8C,SAAS;AACvD;AACA;AACA;;AAEA;;AAEA,qBAAoB;AACpB,UAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA,2BAA0B,OAAO;AACjC,0DAAyD,SAAS;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC,OAAO;AAC9C,8DAA6D,SAAS;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mDAAkD,SAAS;AAC3D;AACA,oCAAmC,qBAAqB;AACxD;AACA;AACA;AACA;;AAEA;;AAEA,+CAA8C,QAAQ;AACtD;AACA;AACA;AACA;;AAEA,qBAAoB;AACpB,UAAS;;AAET;AACA;AACA;AACA,0BAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAkB;AAClB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAuB,qBAAqB;AAC5C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA,EAAC;AACD,wB;;;;;;AC3QA;;AAEA;;AAEA;AACA;AACA;;AAEA,8BAA6B;AAC7B,4BAA2B;AAC3B,kCAAiC;AACjC;AACA;AACA,uCAAsC;;AAEtC;AACA;;AAEA,0BAAyB,+BAA+B;AACxD,iCAAgC,gCAAgC;AAChE,sBAAqB,2BAA2B;AAChD,6BAA4B,4BAA4B;AACxD,2BAA0B,gCAAgC;AAC1D,kCAAiC,iCAAiC;AAClE,mCAAkC,wCAAwC;AAC1E,0CAAyC,yCAAyC;AAClF,8BAA6B,mCAAmC;AAChE,qCAAoC,oCAAoC;AACxE,iCAAgC,sCAAsC;AACtE,wCAAuC,uCAAuC;AAC9E;;AAEA,4C;;;;;;AChCA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,oBAAmB;;AAEnB;AACA;AACA,mBAAkB,WAAW;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,wBAAuB,0BAA0B;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAY;AACZ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAY;AACZ;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,UAAS,wBAAwB;;AAEjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAkC;AAClC;AACA;AACA,oCAAmC;AACnC;AACA;AACA,gBAAe,wBAAwB;AACvC;;AAEA;AACA;;AAEA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAmB,kBAAkB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAmB,sBAAsB;AACzC;;AAEA;AACA;AACA,qBAAoB,YAAY;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAgB,YAAY,MAAM,eAAe;AACjD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAU,WAAW;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAU,WAAW;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,sDAAqD,8BAA8B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,6B;;;;;;ACvTA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA0B,gCAAgC;AAC1D,kCAAiC,iCAAiC;AAClE,yBAAwB,8BAA8B;AACtD,gCAA+B,+BAA+B;AAC9D,0BAAyB,+BAA+B;AACxD,iCAAgC,gCAAgC;AAChE,0BAAyB,+BAA+B;AACxD,iCAAgC,gCAAgC;AAChE,oCAAmC,yCAAyC;AAC5E,2CAA0C,0CAA0C;AACpF,+BAA8B,oCAAoC;AAClE,sCAAqC,qCAAqC;AAC1E;;AAEA,qC","file":"sgwm.module.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 74e564aed31873e89abd","/*\r\n    Main class (and entry point), unites all the fuctionality\r\n*/\r\n'use strict';\r\n\r\nconst FixationProcessor = require('./fixationProcessor');\r\nconst splitToProgressions = require('./splitToProgressions');\r\nconst TextModel = require('./textModel');\r\nconst ProgressionMerger = require('./progressionMerger');\r\nconst WordMapper = require('./wordMapper');\r\n\r\nconst FixationProcessorSettings = require('./fixationProcessorSettings');\r\nconst ProgressionMergerSettings = require('./progressionMergerSettings');\r\nconst SplitToProgressionsSettings = require('./splitToProgressionsSettings');\r\nconst WordMapperSettings = require('./wordMapperSettings');\r\n\r\nclass SGWM {\r\n\tconstructor( logger ) {\r\n        this.logger = logger;\r\n\t}\r\n\r\n\t// Arguments:\r\n\t//\tdata ({\r\n\t//\t\tfixations (Array of Fixations)\r\n    //          Fixation = {ts, x, y, duration}\r\n\t//\t\twords (Aarray of Word)\r\n    //          Word = {x, y, width, height, text, row:optional=<line ID starting form 1>}\r\n\t//\t})\r\n    map( data ) {\r\n        let fixations = data.fixations;\r\n        const words = data.words;\r\n\r\n        if (!fixations || !words) {\r\n            return;\r\n        }\r\n\r\n        const text = new TextModel( data.words );\r\n\r\n        fixations = fixations.map( (fixation, i) => Object.assign( { id: i }, fixation ) );\r\n\r\n        const fixationProcessor = new FixationProcessor( this.logger );\r\n    \tfixations = fixationProcessor.filterByLocation( fixations, text.box );\r\n    \tfixations = fixationProcessor.filterByDuration( fixations );\r\n\r\n    \tconst progressions = splitToProgressions( fixations, text.lineHeight, text.interlineDistance );\r\n\r\n\t\tconst merger = new ProgressionMerger( text.interlineDistance, this.logger );\r\n    \tconst fixationLines = merger.merge( progressions, text.lines );\r\n\r\n\t    const wordMapper = new WordMapper( this.logger );\r\n\t    wordMapper.map( fixationLines, text.lines );\r\n\t    wordMapper.clean( fixations, text.words );\r\n\r\n    \treturn { fixations, text };\r\n    }\r\n\r\n    static get FixationProcessorSettings() { return FixationProcessorSettings; }\r\n    static get ProgressionMergerSettings() { return ProgressionMergerSettings; }\r\n    static get SplitToProgressionsSettings() { return SplitToProgressionsSettings; }\r\n    static get WordMapperSettings() { return WordMapperSettings; }\r\n}\r\n\r\nmodule.exports = SGWM;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sgwm.js\n// module id = 0\n// module chunks = 0","/*\r\n    Reprocesses or filter out fixatins based on their properties\r\n*/\r\n'use strict';\r\n\r\nconst FixationProcessorSettings = require('./fixationProcessorSettings');\r\n\r\nconst settings = new FixationProcessorSettings();\r\n\r\nlet log = () => {}; // Function( module, ...messages )\r\n\r\nclass FixationProcessor {\r\n    // Arguments:\r\n    //   logger ({ log(...) }): optional logger\r\n    constructor( logger ) {\r\n        settings.load();\r\n\r\n        if (logger) {\r\n            logger.log( '. . . . . . . . .' );\r\n            log = (...params) => {\r\n                logger.log( 'FixationProcessor   ', ...params );\r\n            };\r\n        }\r\n    }\r\n\r\n    // Arguments\r\n    //   fixations (Array of Fixation)\r\n    //   textbox {left, right, top, bottom}\r\n    // Returns\r\n    //   new array with original fixations (Array of Fixation)\r\n    filterByLocation( fixations, textbox ) {\r\n        if (!settings.location.enabled || !textbox) {\r\n            return fixations;\r\n        }\r\n\r\n        const result = [];\r\n\r\n        for (let i = 0; i < fixations.length; i += 1) {\r\n            const fixation = fixations[i];\r\n            if (fixation.x > textbox.left - settings.location.marginX &&\r\n                    fixation.x < textbox.right + settings.location.marginX &&\r\n                    fixation.y > textbox.top - settings.location.marginY &&\r\n                    fixation.y < textbox.bottom + settings.location.marginY) {\r\n                result.push( fixation );\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // Arguments:\r\n    //   fixations (Array of Fixation)\r\n    // Returns\r\n    //   new array of fixations\r\n    //   (the merged fixations have property \"merged\" = <number of merged fixations>)\r\n    filterByDuration( fixations ) {\r\n        if (!settings.duration.enabled) {\r\n            return fixations;\r\n        }\r\n\r\n        let fixationCount;\r\n        let result = fixations;\r\n\r\n        do {\r\n            fixationCount = result.length;\r\n            result = joinOrDeleteShortFixations( result );\r\n        } while (result.length !== fixationCount);\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n// Calculated distance between 2 fixations\r\nfunction dist( a, b ) {\r\n    return Math.sqrt( Math.pow( a.x - b.x, 2 ) + Math.pow( a.y - b.y, 2 ) );\r\n}\r\n\r\n// Joins 2 fixations, saves the result to the first fixation,\r\n// and adds property \"merged\" = <number of merged fixations>\r\nfunction join( a, b ) {\r\n    const totalDuration = a.duration + b.duration;\r\n    a.x = (a.x * a.duration + b.x * b.duration) / totalDuration;\r\n    a.y = (a.y * a.duration + b.y * b.duration) / totalDuration;\r\n    a.duration = totalDuration;\r\n    a.merged = (a.merged || 1) + (b.merged || 1);\r\n    log( 'joined', b.id, 'to', a.id );\r\n    return a;\r\n}\r\n\r\n// Tries to join the fixation\r\n// Arguments:\r\n//      fixation (Fixation)\r\n//      prev (Fixation)\r\n//      next (Fixation)\r\n// Returns\r\n//      true if the fixation was joined and the original instance should be removed\r\nfunction tryJoinFixation( fixation, prev, next ) {\r\n    const distToPrev = prev ? dist( fixation, prev ) : Number.MAX_VALUE;\r\n    const distToNext = next ? dist( fixation, next ) : Number.MAX_VALUE;\r\n    if (distToPrev < settings.duration.mergingDistanceThreshold || distToNext < settings.duration.mergingDistanceThreshold) {\r\n        if (distToNext < distToPrev) {\r\n            join( next, fixation );\r\n        }\r\n        else {\r\n            join( prev, fixation );\r\n        }\r\n        return true;\r\n    }\r\n    else if (fixation.duration < settings.duration.removingDurationThreshold) {\r\n        log( 'removed', fixation.id );\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n// Cycle all fixations and joins or deletes too short\r\n// Returns\r\n//   new sequence of fixations (Array of Fixation)\r\nfunction joinOrDeleteShortFixations( fixations ) {\r\n    const result = [];\r\n\r\n    let prevFix, prevPrevFix;\r\n    for (let i = 0; i < fixations.length; i += 1) {\r\n        const fixation = fixations[i];\r\n\r\n        if (prevFix && prevFix.duration < settings.duration.mergingDurationThreshold ) {\r\n            if (tryJoinFixation( prevFix, prevPrevFix, fixation )) {\r\n                result.pop();\r\n                prevFix = prevPrevFix;\r\n            }\r\n        }\r\n\r\n        result.push( fixation );\r\n\r\n        prevPrevFix = prevFix;\r\n        prevFix = fixation;\r\n    }\r\n\r\n    if (prevFix.duration < settings.duration.mergingDurationThreshold) {\r\n        if (tryJoinFixation( prevFix, prevPrevFix, null )) {\r\n          result.pop();\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nmodule.exports = FixationProcessor;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./fixationProcessor.js\n// module id = 1\n// module chunks = 0","'use strict';\r\n\r\nconst Settings = require('./settings');\r\n\r\nclass FixationProcessorSettings extends Settings {\r\n\tconstructor() {\r\n\t\tsuper( 'fixationProcessorSettings' );\r\n\t\tthis._location = {\r\n\t\t\tenabled: false,\r\n\t\t\tmarginX: 200,\r\n\t\t\tmarginY: 200\r\n\t\t};\r\n\t\tthis._duration = {\r\n\t\t\tenabled: false,\r\n\t\t\tmergingDistanceThreshold: 40,\r\n\t\t\tmergingDurationThreshold: 100,\r\n\t\t\tremovingDurationThreshold: 80\r\n\t\t};\r\n\r\n\t\tsuper.load();\r\n\t}\r\n\r\n\tget location() { return this._location; }\r\n\tset location( value ) { this._location = value; }\r\n\tget duration() { return this._duration; }\r\n\tset duration( value ) { this._duration = value; }\r\n}\r\n\r\nmodule.exports = FixationProcessorSettings;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./fixationProcessorSettings.js\n// module id = 2\n// module chunks = 0","/*\r\n\tBase class for settings\r\n*/\r\n'use strict';\r\n\r\nclass Settings {\r\n\t// Arguments:\r\n\t//\t name (string): settings own namespace (without domain which is defined in the class)\r\n\tconstructor( name ) {\r\n\t\tthis._name = name;\r\n\t\tthis._domain = 'sgwm';\r\n\r\n\t\tthis._fullPath = function( name ) {\r\n\t\t\treturn [ this._domain, this._name, name ].join( '_' );\r\n\t\t};\r\n\t}\r\n\r\n\tload() {\r\n\t\tconst hiddenProps = Object.keys(new Settings(''));\r\n\r\n\t\tfor (let p in this) {\r\n\t\t\tif (hiddenProps.indexOf( p ) > -1) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tconst value = JSON.parse( localStorage.getItem( this._fullPath( p ) ) );\r\n\t\t\tif (value !== null) {\r\n\t\t\t\tthis[p] = value;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tsave() {\r\n\t\tconst hiddenProps = Object.keys(new Settings(''));\r\n\r\n\t\tfor (let p in this) {\r\n\t\t\tif (hiddenProps.indexOf( p ) > -1) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tlocalStorage.setItem( this._fullPath( p ), JSON.stringify( this[p] ) );\r\n\t\t}\r\n\t}\r\n}\r\n\r\nmodule.exports = Settings;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./settings.js\n// module id = 3\n// module chunks = 0","/*\r\n\tCreate a set of chunks of progressive reading fixations\r\n*/\r\n'use strict';\r\n\r\nconst SplitToProgressionsSettings = require('./splitToProgressionsSettings');\r\n\r\nconst settings = new SplitToProgressionsSettings();\r\nlet progressionBox;\r\n\r\nconst isProgressiveReadingSaccade = function( dx, dy ) {\r\n\treturn (\r\n\t\tdx > progressionBox.left &&\r\n\t\tdx < progressionBox.right &&\r\n\t\tMath.abs( dy ) < progressionBox.vertical( dx )\r\n\t);\r\n};\r\n\r\n// Arguments:\r\n//   fixations (Array of Fixation)\r\n//   lineHeight (Number): word box height in pixels\r\n// Returns:\r\n//   A set of progresions which are the sequences of fixations (Array of (Array of Fixation))\r\n// Note:\r\n//   Fixations in the output are referencing to the fixations in the input (no copying)\r\nmodule.exports = function( fixations, lineHeight, interlineDistance ) {\r\n    settings.load();\r\n    progressionBox = settings.pixelBounds( lineHeight, interlineDistance );\r\n\r\n    const result = [];\r\n    let currentProgression;\r\n\r\n    const startNewProgression = function( fixation ) {\r\n        currentProgression = [ fixation ];\r\n        result.push( currentProgression );\r\n    };\r\n\r\n    let lastFix = fixations[0];\r\n    startNewProgression( lastFix );\r\n\r\n    for (let i = 1; i < fixations.length; i += 1) {\r\n        const fixation = fixations[i];\r\n        if (!isProgressiveReadingSaccade( fixation.x - lastFix.x, fixation.y - lastFix.y )) {\r\n            startNewProgression( fixation );\r\n        }\r\n        else {\r\n            currentProgression.push( fixation );\r\n        }\r\n        lastFix = fixation;\r\n    }\r\n\r\n    return result;\r\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./splitToProgressions.js\n// module id = 4\n// module chunks = 0","'use strict';\r\n\r\nconst Settings = require('./settings');\r\n\r\nclass ProgressionSplitterSettings extends Settings {\r\n\tconstructor() {\r\n\t\tsuper( 'progressionSplitterSettings' );\r\n\t\tthis._bounds = {\r\n\t\t\tleft: -0.5,\r\n\t\t\tright: 10,\r\n\t\t\tverticalChar: 1.5,\t// in characters\r\n\t\t\tverticalLine: 0.65,\t// in interline distances\r\n\t\t};\r\n\t\tthis._angle = Math.sin( 15 * Math.PI / 180 );\r\n\r\n\t\tsuper.load();\r\n\t}\r\n\r\n\tget bounds() { return this._bounds; }\r\n\tset bounds( value ) { this._bounds = value; }\r\n\tget angle() { return this._angle; }\r\n\tset angle( value ) { this._angle = value; }\r\n\r\n\tpixelBounds( lineHeight, interlineDistance ) {\r\n\t\tconst vertical = Math.min(\r\n\t\t\tthis._bounds.verticalChar * lineHeight,\r\n\t\t\tthis._bounds.verticalLine * interlineDistance\r\n\t\t);\r\n\r\n\t\treturn {\r\n\t\t\tleft: this._bounds.left * lineHeight,\r\n\t\t\tright: this._bounds.right * lineHeight,\r\n\t\t\tvertical: dx => vertical + dx * this._angle,\r\n\t\t\t_vertical: vertical\r\n\t\t};\r\n\t}\r\n}\r\n\r\nmodule.exports = ProgressionSplitterSettings;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./splitToProgressionsSettings.js\n// module id = 5\n// module chunks = 0","/*\r\n\tCreates an array lines, each as array of word boxes\r\n*/\r\n'use strict';\r\n\r\nclass TextModel {\r\n\t// Arguments\r\n\t//\t words (Array of {x, y, width, height, text, row:optional=<line ID starting form 1>})\r\n    // Notes:\r\n    //   1. each word gets property \"id\" = <index in the text>\r\n    //   2. the words in \"lines\" and \"wrods\" properties are copied (and shared between these two properties)\r\n\tconstructor( words ) {\r\n        const lines = [];\r\n        const wordList = [];\r\n        const box = {\r\n        \tleft: Number.MAX_VALUE,\r\n        \ttop: Number.MAX_VALUE,\r\n        \tright: 0,\r\n        \tbottom: 0\r\n        };\r\n\r\n        let currentLine;\r\n\r\n        const createNewLine = function( word ) {\r\n            currentLine = [ word ];\r\n            currentLine.id = word.row === undefined ? lines.length : word.row - 1;\r\n            currentLine.y = word.y;\r\n            lines.push( currentLine );\r\n        };\r\n\r\n        let currentY = Number.MIN_VALUE;\r\n        for (let i = 0; i < words.length; i += 1) {\r\n            const word = Object.assign( {}, words[i] );\r\n            wordList.push( word );\r\n\r\n            word.id = i;\r\n            if (word.x < box.left) { box.left = word.x; }\r\n            if (word.y < box.top) { box.top = word.y; }\r\n            if (word.x + word.width > box.right) { box.right = word.x + word.width; }\r\n            if (word.y + word.height > box.bottom) { box.bottom = word.y + word.height; }\r\n\r\n            if (word.y != currentY) {\r\n                currentY = word.y;\r\n                createNewLine( word );\r\n            }\r\n            else {\r\n                currentLine.push( word );\r\n            }\r\n        }\r\n\r\n        this._box = box;\r\n        this._lines = lines;\r\n        this._words = wordList;\r\n\r\n        this._lineHeight = lines[0][0].height;\r\n        this._interlineDistance = getInterlineDistance( lines );\r\n\t}\r\n\r\n\tget box() { return this._box; }\r\n\tget lines() { return this._lines; }\r\n    get words() { return this._words; }\r\n\tget lineHeight() { return this._lineHeight;\t}\r\n    get interlineDistance() { return this._interlineDistance; }\r\n}\r\n\r\nfunction getInterlineDistance( lines ) {\r\n    let interlineDist = 9;\r\n    if (lines.length > 1) {\r\n        const interlineDists = [];\r\n        for (let i = 1; i < lines.length; i += 1) {\r\n            interlineDists.push( lines[i].y - lines[i - 1].y );\r\n        }\r\n        interlineDist = median( interlineDists );\r\n        /*/\r\n        for (let i = 1; i < textLines.length; i += 1) {\r\n            interlineDist += textLines[i].y - textLines[i - 1].y;\r\n        }\r\n        interlineDist = interlineDist / (textLines.length - 1);\r\n        */\r\n    }\r\n    else {\r\n        interlineDist = Number.MAX_VALUE;\r\n    }\r\n\r\n    return interlineDist;\r\n}\r\n\r\nfunction median( array ) {\r\n    if (array.length <= 5) {\r\n        return array[ Math.floor( array.length / 2 ) ];\r\n    }\r\n\r\n    const sets = new Array( Math.floor( array.length / 5 ) + (array.length % 5 ? 1 : 0) );\r\n    for (let i = 0; i < sets.length; i+=1) {\r\n        sets[i] = [];\r\n    }\r\n    for (let i = 0; i < array.length; i+=1) {\r\n        sets[ Math.floor( i / 5 ) ].push( array[i] );\r\n    }\r\n\r\n    let medians = [];\r\n    sets.forEach( set => {\r\n        set.sort( (a, b) => {\r\n            return a - b;\r\n        });\r\n        medians.push( set[ Math.floor( set.length / 2 ) ] );\r\n    });\r\n\r\n    return median( medians );\r\n}\r\n\r\nmodule.exports = TextModel;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./textModel.js\n// module id = 6\n// module chunks = 0","/*\r\n    Merges progressive reading fixations within the text lines\r\n*/\r\n'use strict';\r\n\r\nconst regression = require('./regression.js');\r\nconst ProgressionMergerSettings = require('./progressionMergerSettings');\r\n\r\nconst settings = new ProgressionMergerSettings();\r\n\r\nconst SET_TYPE = {\r\n    LONG: 1,\r\n    SHORT: 2,\r\n    ANY: 3\r\n};\r\n\r\nlet interlineDistance = 30;\r\n\r\nlet log = () => {}; // Function( module, ...messages )\r\n\r\nclass ProgressionMerger {\r\n    // Arguments:\r\n    //   interlineDistance (Number): inter-line distance in pixels\r\n    //   logger ({ log(...) }): optional logger\r\n    constructor( _interlineDistance, logger ) {\r\n        interlineDistance = _interlineDistance;\r\n\r\n        settings.load();\r\n        settings.fitThreshold *= interlineDistance;\r\n\r\n        if (logger) {\r\n            logger.log( '. . . . . . . . .' );\r\n            log = (...params) => {\r\n                logger.log( 'ProgressionMerger   ', ...params );\r\n            };\r\n        }\r\n    }\r\n\r\n    // Arguments:\r\n    //   progressions (Array of (Array of Fixation))\r\n    //   textLines (Array of (Array of word))\r\n    // Returns:\r\n    //   new sorted array of original and merged progressions (Array of (Array of Fixation))\r\n    // Notes:\r\n    //   1. Fixations get property \"line\", the index of line they land onto.\r\n    //   2. Merged sets have property \"joined\" = <number of joined progressions>\r\n    //   3. Progressions not included in the resulting array and not merged with other have property \"removed\"\r\n    merge( progressions, textLines ) {\r\n        const lineCount = textLines.length;\r\n\r\n        let result = progressions.map( set => set );\r\n        log( '#0:', result.length, '\\n', result.map( set => (set.map( fix => fix.id ))) );\r\n\r\n        // 1. join only long sets\r\n        result = joinSetsOfType( result, lineCount, SET_TYPE.LONG, SET_TYPE.LONG, settings.minLongSetLength );\r\n        log( '#1a:', result.length );\r\n\r\n        // 2. join short sets with long sets\r\n        result = joinSetsOfType( result, lineCount, SET_TYPE.SHORT, SET_TYPE.LONG, settings.minLongSetLength );\r\n        log( '#1b:', result.length );\r\n\r\n        // 3. join the remaining single-fixation sets with multi-fixation sets\r\n        const multiFixationSetLength = 2;\r\n        result = joinSetsOfType( result, lineCount, SET_TYPE.SHORT, SET_TYPE.LONG, multiFixationSetLength );\r\n        log( '#1c:', result.length );\r\n\r\n        if (result.length > lineCount) {\r\n            // still too many: join any multi-fixation set with any other multi-fixation set\r\n            result = joinSetsOfType( result, lineCount, SET_TYPE.LONG, SET_TYPE.LONG, multiFixationSetLength );\r\n            log( '#2:', result.length );\r\n        }\r\n        else if (settings.removeSingleFixationLines) {\r\n            result = dropShortSets( result, 2 );\r\n        }\r\n\r\n        if (result.length > lineCount) {\r\n            // and still too many...\r\n            // drop short sets\r\n            result = dropShortSets( result, settings.minLongSetLength );\r\n            log( '#3a:', result.length );\r\n\r\n            // then force joining the closest sets\r\n            result = joinSetsOfType( result, lineCount, SET_TYPE.ANY, SET_TYPE.ANY );\r\n            log( '#3b:', result.length );\r\n        }\r\n\r\n        align( result, textLines );\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\nfunction joinSetsOfType( fixationsSets, lineCount, primarySetType, secondarySetType, minLongSetLength ) {\r\n    let result = fixationsSets;\r\n    const forced = primarySetType === SET_TYPE.ANY && secondarySetType === SET_TYPE.ANY;\r\n\r\n    while (result.length > lineCount) {\r\n        const pairs = createPairs( result, primarySetType, secondarySetType, minLongSetLength );\r\n        const updatedSets = findAndJoinClosestPair( result, pairs, forced );\r\n\r\n        if (!updatedSets) {\r\n            break;\r\n        }\r\n\r\n        result = updatedSets;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**********************\r\n    createPairs\r\n**********************/\r\n\r\nfunction isValidSet( set, lengthType, lengthTypeThreshold) {\r\n    if (lengthType === SET_TYPE.LONG && set.length < lengthTypeThreshold) {\r\n        return false;\r\n    }\r\n    else if (lengthType === SET_TYPE.SHORT && set.length >= lengthTypeThreshold) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\n// function getFittingError( fixations, model ) {\r\n//     let error = 0;\r\n\r\n//     for (let i = 0; i < fixations.length; i += 1) {\r\n//         const fixation = fixations[i];\r\n//         const y = regression.fit( model, fixation.x );\r\n//         error += (fixation.y - y) * (fixation.y - y);\r\n//     }\r\n\r\n//     return Math.sqrt( error / fixations.length );\r\n// }\r\n\r\nfunction fixationsToArray( fixations ) {\r\n    const result = [];\r\n    for (let i = 0; i < fixations.length; i += 1) {\r\n        const fixation = fixations[i];\r\n        result.push([ fixation.x, fixation.y ]);\r\n    }\r\n    return result;\r\n}\r\n\r\nfunction getFitError( fixations ) {\r\n    const model = regression.model( 'linear', fixationsToArray( fixations ) );\r\n\r\n    let error = 0;\r\n\r\n    for (let i = 0; i < fixations.length; i += 1) {\r\n        const fixation = fixations[i];\r\n        const y = regression.fit( model.equation, fixation.x );\r\n        error += (fixation.y - y) * (fixation.y - y);\r\n    }\r\n\r\n    return Math.sqrt( error / fixations.length );\r\n}\r\n\r\nfunction createPairs( fixationsSets, primarySetType, secondarySetType, setSetTypeThreshold) {\r\n    const pairs = [];\r\n\r\n    for (let i = 0; i < fixationsSets.length; i += 1) {\r\n        const set1 = fixationsSets[i];\r\n        if (!isValidSet( set1, primarySetType, setSetTypeThreshold )) {\r\n            continue;\r\n        }\r\n\r\n        // Compute error of fitting to linear model for each pair of sets\r\n        for (let j = 0; j < fixationsSets.length; j += 1) {\r\n            if (i === j) {\r\n                continue;\r\n            }\r\n\r\n            const set2 = fixationsSets[j];\r\n            if (!isValidSet( set2, secondarySetType, setSetTypeThreshold )) {\r\n                continue;\r\n            }\r\n\r\n            const joinedSets = set1.concat( set2 );\r\n\r\n            pairs.push({\r\n                set1: i,\r\n                set2: j,\r\n                error: getFitError( joinedSets )\r\n            });\r\n        }\r\n    }\r\n\r\n    return pairs;\r\n}\r\n\r\n/**********************\r\n    findAndJoinClosestPair\r\n**********************/\r\n\r\nfunction joinSets( fixationsSets, id1, id2, forced ) {\r\n    const maxGradient = forced ? Number.MAX_VALUE : settings.maxLinearGradient;\r\n\r\n    const set1 = fixationsSets[ id1 ];\r\n    const set2 = fixationsSets[ id2 ];\r\n    const joinedSet = set1.concat( set2 );\r\n    joinedSet.joined = (set1.joined || 1) + (set2.joined || 1);\r\n\r\n    const model = regression.model( 'linear', fixationsToArray( joinedSet ) );\r\n    const gradient = model.equation[1];\r\n\r\n    if (Math.abs( gradient ) < maxGradient) {\r\n        const minIndex = Math.min( id1, id2 );\r\n        const maxIndex = Math.max( id1, id2 );\r\n\r\n        fixationsSets.splice( maxIndex, 1 );\r\n        fixationsSets.splice( minIndex, 1 );\r\n        fixationsSets.push( joinedSet );\r\n\r\n        log( 'joined', id1 + ' = ' + set1.map( fix => fix.id), ' & ', id2 + ' = ' + set2.map( fix => fix.id) );\r\n        log( '--->\\n', fixationsSets.map( set => set.map( fix => fix.id ) ) );\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction findAndJoinClosestPair( fixationsSets, pairs, forced ) {\r\n    let result;\r\n\r\n    const fitThreshold = forced ? Number.MAX_VALUE : settings.fitThreshold;\r\n\r\n    // holds pairs that produce too inclined set\r\n    const invalidPairs = {};\r\n\r\n    do {\r\n        // find 2 nearest sets, i.e. the pair with smallest error\r\n        let minError = Number.MAX_VALUE;\r\n        let minIndex = -1;\r\n        for (let i = 0; i < pairs.length; i += 1) {\r\n            if (invalidPairs[i]) {\r\n                continue;\r\n            }\r\n            const pair = pairs[i];\r\n            if (pair.error < minError) {\r\n                minIndex = i;\r\n                minError = pair.error;\r\n            }\r\n        }\r\n\r\n        // if found, try to join them\r\n        if (minIndex >= 0 && minError < fitThreshold) {\r\n            const pair = pairs[ minIndex ];\r\n            const success = joinSets( fixationsSets, pair.set1, pair.set2, forced );\r\n            if (success) {\r\n                result = fixationsSets;\r\n            }\r\n            else {\r\n                invalidPairs[ minIndex ] = true;\r\n            }\r\n        }\r\n        else {\r\n            result = null;\r\n        }\r\n\r\n        // break only when\r\n        //  - all pairs have too distant components, or\r\n        //  - all pairs have very distinctly inclined set of fixations, or\r\n        //  - a pair of the closest sets was joined\r\n    } while (result === undefined);\r\n\r\n    return result;\r\n}\r\n\r\n/**********************\r\n    align\r\n**********************/\r\nfunction avgY( fixations ) {\r\n    let sumY = 0;\r\n    for (let i = 0; i < fixations.length; i += 1) {\r\n        sumY += fixations[i].y;\r\n    }\r\n    return sumY / fixations.length;\r\n}\r\n\r\nfunction sortSets( fixationsSets ) {\r\n    fixationsSets.sort( (set1, set2) => {\r\n        return avgY( set1 ) - avgY( set2 );\r\n    });\r\n    fixationsSets.forEach( set => {\r\n        set.sort( (fix1, fix2) => {\r\n            return fix1.ts - fix2.ts;\r\n        });\r\n    });\r\n}\r\n\r\nfunction align( fixationsSets, textLines ) {\r\n\r\n    sortSets( fixationsSets );\r\n\r\n    let minID = Number.MAX_VALUE;\r\n    let maxID = 0;\r\n    textLines.forEach( line => {\r\n        if (minID > line.id) {\r\n            minID = line.id;\r\n        }\r\n        if (maxID < line.id) {\r\n            maxID = line.id;\r\n        }\r\n    });\r\n\r\n    let currentLineID = 0;\r\n    let lastSetY;\r\n    // let lastLineY;\r\n\r\n    for (let i = 0; i < fixationsSets.length; i += 1) {\r\n        const fixations = fixationsSets[i];\r\n        const currentSetY = avgY( fixations );\r\n        // let currentLineY;\r\n\r\n        const initialLineID = currentLineID;\r\n        if (settings.correctForEmptyLines && i > 0) {\r\n            /*\r\n            while (currentLineID < textLines.length) {\r\n                currentLineY = textLines[ currentLineID ].y;\r\n\r\n                const setDist = currentSetY - lastSetY;\r\n                const lineDist = currentLineY - lastLineY;\r\n\r\n                if (setDist < settings.emptyLineDetectorFactor * lineDist) {\r\n                    break;\r\n                }\r\n\r\n                currentLineID += 1;\r\n            }\r\n            */\r\n            const lineIDsFromMappedSets = [];\r\n            for (let j = 0; j < i; j += 1) {\r\n                const prevSet = fixationsSets[j];\r\n                if (prevSet[0].line === undefined) {\r\n                    continue;\r\n                }\r\n\r\n                const prevSetY = avgY( prevSet );\r\n                lineIDsFromMappedSets.push( prevSet[0].line + (currentSetY - prevSetY) / interlineDistance );\r\n            }\r\n\r\n            if (lineIDsFromMappedSets.length) {\r\n                const avgID = lineIDsFromMappedSets.reduce( (acc, id) => {\r\n                    return acc + id;\r\n                }, 0 ) / lineIDsFromMappedSets.length;\r\n                currentLineID = Math.min( maxID, Math.max( minID, Math.round( avgID ) ) );\r\n            }\r\n            else {\r\n                currentLineID += 1;\r\n            }\r\n        }\r\n        // else {\r\n        //     currentLineY = textLines[ currentLineID ].y;\r\n        // }\r\n\r\n        if (initialLineID !== currentLineID) {\r\n            log( `Line advanced: #${initialLineID} => ${currentLineID}` );\r\n        }\r\n\r\n        for (let j = 0; j < fixations.length; j += 1) {\r\n            fixations[j].line = currentLineID;\r\n        }\r\n\r\n        // lastLineY = currentLineY;\r\n        lastSetY = currentSetY;\r\n\r\n        currentLineID += 1;\r\n        // if (currentLineID >= textLines.length) {\r\n        //     break;\r\n        // }\r\n\r\n        // currentLineY = textLines[ currentLineID ].y;\r\n    }\r\n// fixationsSets.forEach( (p, pi) => {\r\n//     console.log('--',pi,'--');\r\n//     console.log( p.map( (f, fi) => { return f.line; } ).join(' ') ) ;\r\n// });\r\n}\r\n\r\n/**********************\r\n    dropShortSets\r\n**********************/\r\nfunction dropShortSets( fixationSets, minLength ) {\r\n    var result = [];\r\n\r\n    for (var i = 0; i < fixationSets.length; i += 1) {\r\n        var fixationSet = fixationSets[i];\r\n        if (fixationSet.length >= minLength) {\r\n            result.push( fixationSet );\r\n        }\r\n        else {\r\n            fixationSet.removed = true;\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nmodule.exports = ProgressionMerger;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./progressionMerger.js\n// module id = 7\n// module chunks = 0","/**\r\n* @license\r\n*\r\n* Regression.JS - Regression functions for javascript\r\n* http://tom-alexander.github.com/regression-js/\r\n*\r\n* copyright(c) 2013 Tom Alexander\r\n* Licensed under the MIT license.\r\n*\r\n**/\r\n/* jshint ignore:start */\r\n;(function() {\r\n    'use strict';\r\n\r\n    var gaussianElimination = function(a, o) {\r\n           var i = 0, j = 0, k = 0, maxrow = 0, tmp = 0, n = a.length - 1, x = new Array(o);\r\n           for (i = 0; i < n; i++) {\r\n              maxrow = i;\r\n              for (j = i + 1; j < n; j++) {\r\n                 if (Math.abs(a[i][j]) > Math.abs(a[i][maxrow]))\r\n                    maxrow = j;\r\n              }\r\n              for (k = i; k < n + 1; k++) {\r\n                 tmp = a[k][i];\r\n                 a[k][i] = a[k][maxrow];\r\n                 a[k][maxrow] = tmp;\r\n              }\r\n              for (j = i + 1; j < n; j++) {\r\n                 for (k = n; k >= i; k--) {\r\n                    a[k][j] -= a[k][i] * a[i][j] / a[i][i];\r\n                 }\r\n              }\r\n           }\r\n           for (j = n - 1; j >= 0; j--) {\r\n              tmp = 0;\r\n              for (k = j + 1; k < n; k++)\r\n                 tmp += a[k][j] * x[k];\r\n              x[j] = (a[n][j] - tmp) / a[j][j];\r\n           }\r\n           return (x);\r\n    };\r\n\r\n    var methods = {\r\n        linear: function(data) {\r\n            var sum = [0, 0, 0, 0, 0], n = 0, results = [];\r\n\r\n            for (; n < data.length; n++) {\r\n              if (data[n][1] != null) {\r\n                sum[0] += data[n][0];\r\n                sum[1] += data[n][1];\r\n                sum[2] += data[n][0] * data[n][0];\r\n                sum[3] += data[n][0] * data[n][1];\r\n                sum[4] += data[n][1] * data[n][1];\r\n              }\r\n            }\r\n\r\n            var gradient = (n * sum[3] - sum[0] * sum[1]) / (n * sum[2] - sum[0] * sum[0]);\r\n            var intercept = (sum[1] / n) - (gradient * sum[0]) / n;\r\n          //  var correlation = (n * sum[3] - sum[0] * sum[1]) / Math.sqrt((n * sum[2] - sum[0] * sum[0]) * (n * sum[4] - sum[1] * sum[1]));\r\n\r\n            for (var i = 0, len = data.length; i < len; i++) {\r\n                var coordinate = [data[i][0], data[i][0] * gradient + intercept];\r\n                results.push(coordinate);\r\n            }\r\n\r\n            var string = 'y = ' + Math.round(gradient*100) / 100 + 'x + ' + Math.round(intercept*100) / 100;\r\n\r\n            return {equation: [intercept, gradient], points: results, string: string};\r\n        },\r\n\r\n        linearThroughOrigin: function(data) {\r\n            var sum = [0, 0], n = 0, results = [];\r\n\r\n            for (; n < data.length; n++) {\r\n                if (data[n][1] != null) {\r\n                    sum[0] += data[n][0] * data[n][0]; //sumSqX\r\n                    sum[1] += data[n][0] * data[n][1]; //sumXY\r\n                }\r\n            }\r\n\r\n            var gradient = sum[1] / sum[0];\r\n\r\n            for (var i = 0, len = data.length; i < len; i++) {\r\n                var coordinate = [data[i][0], data[i][0] * gradient];\r\n                results.push(coordinate);\r\n            }\r\n\r\n            var string = 'y = ' + Math.round(gradient*100) / 100 + 'x';\r\n\r\n            return {equation: [0, gradient], points: results, string: string};\r\n        },\r\n\r\n        exponential: function(data) {\r\n            var sum = [0, 0, 0, 0, 0, 0], n = 0, results = [];\r\n\r\n            for (len = data.length; n < len; n++) {\r\n              if (data[n][1] != null) {\r\n                sum[0] += data[n][0];\r\n                sum[1] += data[n][1];\r\n                sum[2] += data[n][0] * data[n][0] * data[n][1];\r\n                sum[3] += data[n][1] * Math.log(data[n][1]);\r\n                sum[4] += data[n][0] * data[n][1] * Math.log(data[n][1]);\r\n                sum[5] += data[n][0] * data[n][1];\r\n              }\r\n            }\r\n\r\n            var denominator = (sum[1] * sum[2] - sum[5] * sum[5]);\r\n            var A = Math.pow(Math.E, (sum[2] * sum[3] - sum[5] * sum[4]) / denominator);\r\n            var B = (sum[1] * sum[4] - sum[5] * sum[3]) / denominator;\r\n\r\n            for (var i = 0, len = data.length; i < len; i++) {\r\n                var coordinate = [data[i][0], A * Math.pow(Math.E, B * data[i][0])];\r\n                results.push(coordinate);\r\n            }\r\n\r\n            var string = 'y = ' + Math.round(A*100) / 100 + 'e^(' + Math.round(B*100) / 100 + 'x)';\r\n\r\n            return {equation: [A, B], points: results, string: string};\r\n        },\r\n\r\n        logarithmic: function(data) {\r\n            var sum = [0, 0, 0, 0], n = 0, results = [];\r\n\r\n            for (len = data.length; n < len; n++) {\r\n              if (data[n][1] != null) {\r\n                sum[0] += Math.log(data[n][0]);\r\n                sum[1] += data[n][1] * Math.log(data[n][0]);\r\n                sum[2] += data[n][1];\r\n                sum[3] += Math.pow(Math.log(data[n][0]), 2);\r\n              }\r\n            }\r\n\r\n            var B = (n * sum[1] - sum[2] * sum[0]) / (n * sum[3] - sum[0] * sum[0]);\r\n            var A = (sum[2] - B * sum[0]) / n;\r\n\r\n            for (var i = 0, len = data.length; i < len; i++) {\r\n                var coordinate = [data[i][0], A + B * Math.log(data[i][0])];\r\n                results.push(coordinate);\r\n            }\r\n\r\n            var string = 'y = ' + Math.round(A*100) / 100 + ' + ' + Math.round(B*100) / 100 + ' ln(x)';\r\n\r\n            return {equation: [A, B], points: results, string: string};\r\n        },\r\n\r\n        power: function(data) {\r\n            var sum = [0, 0, 0, 0], n = 0, results = [];\r\n\r\n            for (len = data.length; n < len; n++) {\r\n              if (data[n][1] != null) {\r\n                sum[0] += Math.log(data[n][0]);\r\n                sum[1] += Math.log(data[n][1]) * Math.log(data[n][0]);\r\n                sum[2] += Math.log(data[n][1]);\r\n                sum[3] += Math.pow(Math.log(data[n][0]), 2);\r\n              }\r\n            }\r\n\r\n            var B = (n * sum[1] - sum[2] * sum[0]) / (n * sum[3] - sum[0] * sum[0]);\r\n            var A = Math.pow(Math.E, (sum[2] - B * sum[0]) / n);\r\n\r\n            for (var i = 0, len = data.length; i < len; i++) {\r\n                var coordinate = [data[i][0], A * Math.pow(data[i][0] , B)];\r\n                results.push(coordinate);\r\n            }\r\n\r\n             var string = 'y = ' + Math.round(A*100) / 100 + 'x^' + Math.round(B*100) / 100;\r\n\r\n            return {equation: [A, B], points: results, string: string};\r\n        },\r\n\r\n        polynomial: function(data, order) {\r\n            if(typeof order == 'undefined'){\r\n                order = 2;\r\n            }\r\n             var lhs = [], rhs = [], results = [], a = 0, b = 0, i = 0, k = order + 1;\r\n\r\n                    for (; i < k; i++) {\r\n                       for (var l = 0, len = data.length; l < len; l++) {\r\n                          if (data[l][1] != null) {\r\n                           a += Math.pow(data[l][0], i) * data[l][1];\r\n                          }\r\n                        }\r\n                        lhs.push(a), a = 0;\r\n                        var c = [];\r\n                        for (var j = 0; j < k; j++) {\r\n                           for (var l = 0, len = data.length; l < len; l++) {\r\n                              if (data[l][1] != null) {\r\n                               b += Math.pow(data[l][0], i + j);\r\n                              }\r\n                            }\r\n                            c.push(b), b = 0;\r\n                        }\r\n                        rhs.push(c);\r\n                    }\r\n            rhs.push(lhs);\r\n\r\n           var equation = gaussianElimination(rhs, k);\r\n\r\n                for (var i = 0, len = data.length; i < len; i++) {\r\n                    var answer = 0;\r\n                    for (var w = 0; w < equation.length; w++) {\r\n                        answer += equation[w] * Math.pow(data[i][0], w);\r\n                    }\r\n                    results.push([data[i][0], answer]);\r\n                }\r\n\r\n                var string = 'y = ';\r\n\r\n                for(var i = equation.length-1; i >= 0; i--){\r\n                  if(i > 1) string += Math.round(equation[i] * Math.pow(10, i)) / Math.pow(10, i)  + 'x^' + i + ' + ';\r\n                  else if (i == 1) string += Math.round(equation[i]*100) / 100 + 'x' + ' + ';\r\n                  else string += Math.round(equation[i]*100) / 100;\r\n                }\r\n\r\n            return {equation: equation, points: results, string: string};\r\n        },\r\n\r\n        lastvalue: function(data) {\r\n          var results = [];\r\n          var lastvalue = null;\r\n          for (var i = 0; i < data.length; i++) {\r\n            if (data[i][1]) {\r\n              lastvalue = data[i][1];\r\n              results.push([data[i][0], data[i][1]]);\r\n            }\r\n            else {\r\n              results.push([data[i][0], lastvalue]);\r\n            }\r\n          }\r\n\r\n          return {equation: [lastvalue], points: results, string: \"\" + lastvalue};\r\n        }\r\n    };\r\n\r\n    var regression = {\r\n\r\n      model: function(method, data, order) {\r\n\r\n        if (typeof method == 'string') {\r\n          return methods[method](data, order);\r\n        }\r\n      },\r\n\r\n      fit: function (equation, x) {\r\n        var result = 0;\r\n        var value = 1;\r\n\r\n        if (!equation) {\r\n          return Number.MAX_VALUE;\r\n        }\r\n\r\n        for (var i = 0; i < equation.length; ++i) {\r\n          result += equation[i] * value;\r\n          value *= x;\r\n        }\r\n\r\n        return result;\r\n      }\r\n    };\r\n\r\n    if (typeof exports !== 'undefined') {\r\n        module.exports = regression;\r\n    } else {\r\n        window.regression = regression;\r\n    }\r\n\r\n}());\r\n/* jshint ignore:end */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./regression.js\n// module id = 8\n// module chunks = 0","'use strict';\r\n\r\nconst Settings = require('./settings');\r\n\r\nclass ProgressionMergerSettings extends Settings {\r\n\tconstructor() {\r\n\t\tsuper( 'progressionMergerSettings' );\r\n\r\n\t\tthis._minLongSetLength = 3; \t// the minimal length of \"long\" set\r\n\t\tthis._fitThreshold = 0.7;\t\t// fraction of the average inter-line distance\r\n\t\tthis._maxLinearGradient = 0.15; // the maximum difference in equation gradients for fixations that can be joined\r\n\t\tthis._removeSingleFixationLines = false;\r\n\t\tthis._correctForEmptyLines = true;\r\n\t\tthis._emptyLineDetectorFactor = 1.7;\t// multiplier to interlineDistance\r\n\r\n\t\tsuper.load();\r\n\t}\r\n\r\n\tget minLongSetLength() { return this._minLongSetLength; }\r\n\tset minLongSetLength( value ) { this._minLongSetLength = value; }\r\n\tget fitThreshold() { return this._fitThreshold; }\r\n\tset fitThreshold( value ) { this._fitThreshold = value; }\r\n\tget maxLinearGradient() { return this._maxLinearGradient; }\r\n\tset maxLinearGradient( value ) { this._maxLinearGradient = value; }\r\n\tget removeSingleFixationLines() { return this._removeSingleFixationLines; }\r\n\tset removeSingleFixationLines( value ) { this._removeSingleFixationLines = value; }\r\n\tget correctForEmptyLines() { return this._correctForEmptyLines; }\r\n\tset correctForEmptyLines( value ) { this._correctForEmptyLines = value; }\r\n\tget emptyLineDetectorFactor() { return this._emptyLineDetectorFactor; }\r\n\tset emptyLineDetectorFactor( value ) { this._emptyLineDetectorFactor = value; }\r\n}\r\n\r\nmodule.exports = ProgressionMergerSettings;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./progressionMergerSettings.js\n// module id = 9\n// module chunks = 0","/*\r\n\tMaps fixations to words within a line\r\n*/\r\n'use strict';\r\n\r\nconst WordMapperSettings = require('./wordMapperSettings');\r\n\r\nconst settings = new WordMapperSettings();\r\n\r\nlet log = () => {}; // Function( module, ...messages )\r\n\r\nclass WordMapper {\r\n    // Arguments:\r\n    //   logger ({ log(...) }): optional logger\r\n    constructor( logger ) {\r\n        settings.load();\r\n\r\n        if (logger) {\r\n            logger.log( '. . . . . . . . .' );\r\n            log = (...params) => {\r\n                logger.log( 'WordMapper   ', ...params );\r\n            };\r\n        }\r\n    }\r\n\r\n    // Arguments:\r\n    //   fixationLines (Array of (Array of Fixation)): only (all) fixations from one array correspond\r\n    //      to a text line\r\n    //      the array is sorted top-to-bottom\r\n    //   textLines (Array of (Array of Word))\r\n    // Notes\r\n    //   1. If rescaling is enabled, then updates fixation.x value and copies the original value to fixation._x\r\n    //   2, Fixations mapped on a word get property \"word\" =\r\n    //      {left, top, right, bottom, index=<index_in_line>, id=<index_in_text>, text }\r\n    //   3. Words with mapped fixations get property \"fixations\" = (Array of Fixation)\r\n    map( fixationLines, textLines ) {\r\n        for (let i = 0; i < fixationLines.length; i += 1) {\r\n            const fixations = fixationLines[i];\r\n            const lineID = fixations[0].line;\r\n            const textLine = getTextLine( textLines, lineID );\r\n\r\n            if (textLine !== undefined) {\r\n                if (settings.rescaleFixationX) {\r\n                    rescaleFixations( fixations, textLine );\r\n                }\r\n                mapFixationsWithinLine( fixations, textLine );\r\n            }\r\n        }\r\n    }\r\n\r\n    // Arguments:\r\n    //   fixations (Array of Fixation): the list of fixations\r\n    //   words (Array of Word): the Text.words\r\n    clean( fixations, words ) {\r\n        removeTransitions( fixations, words );\r\n    }\r\n}\r\n\r\nfunction getTextLine( textLines, lineID ) {\r\n    let textLine;\r\n    for (let i = 0; i < textLines.length; i += 1) {\r\n        if (lineID === textLines[i].id) {\r\n            textLine = textLines[i];\r\n            break;\r\n        }\r\n    }\r\n    return textLine;\r\n}\r\n\r\n/*****************\r\n    rescaleFixations\r\n*****************/\r\n\r\nfunction getNewLeftMostX( word ) {\r\n    if (word.text.length > 2 * settings.wordCharSkipStart) {\r\n        return word.x + Math.floor( settings.wordCharSkipStart / word.text.length * word.width );\r\n    }\r\n    else {\r\n        return word.x + Math.floor( word.width / 2 );\r\n    }\r\n}\r\n\r\nfunction getNewRightMostX( word ) {\r\n    if (word.text.length > settings.wordCharSkipStart + settings.wordCharSkipEnd) {\r\n        return word.x + Math.floor( (word.text.length - settings.wordCharSkipEnd) / word.text.length * word.width );\r\n    }\r\n    else {\r\n        return word.x + Math.floor( word.width / 2 );\r\n    }\r\n}\r\n\r\nfunction getFixationsRange( fixations ) {\r\n    let leftMostX = Number.MAX_VALUE,\r\n        rightMostX = Number.MIN_VALUE;\r\n\r\n    for (let i = 0; i < fixations.length; i += 1) {\r\n        let fix = fixations[i];\r\n        if (fix.x < leftMostX) {\r\n            leftMostX = fix.x;\r\n        }\r\n        else if (fix.x > rightMostX) {\r\n            rightMostX = fix.x;\r\n        }\r\n    }\r\n\r\n    return { leftMostX, rightMostX };\r\n}\r\n\r\nfunction computeScale( newRange, oldRange ) {\r\n    let scale = newRange / oldRange;\r\n\r\n    // limit the scaling factor\r\n    let newXCorrection = 0;\r\n    if (scale < settings.scalingDiffLimit) {\r\n        scale = settings.scalingDiffLimit;\r\n        newXCorrection = (scale * oldRange - newRange) / 2;\r\n    }\r\n    else if (scale > (2 - settings.scalingDiffLimit)) {\r\n        scale = 2 - settings.scalingDiffLimit;\r\n        newXCorrection = -(scale * oldRange - newRange) / 2;\r\n    }\r\n\r\n    return { scale, newXCorrection };\r\n}\r\n\r\nfunction rescaleFixations( fixations, words ) {\r\n\r\n    const firstWord = words[0];\r\n    const lastWord = words[ words.length - 1 ];\r\n\r\n    const leftThreshold = firstWord.x + firstWord.width;\r\n    const rightThreshold = lastWord.x + lastWord.width;\r\n\r\n    let { leftMostX, rightMostX } = getFixationsRange( fixations );\r\n\r\n    log( 'rescaling...' );\r\n    log( 'left: ' + leftMostX + ' ' + leftThreshold );\r\n    log( 'right: ' + rightMostX + ' ' + rightThreshold );\r\n\r\n    if (leftMostX < leftThreshold || rightMostX > rightThreshold) {\r\n        // Calculate the scaling factor\r\n        let newLeftMostX = leftMostX < leftThreshold ?  // if the left-most fixation lands left to the 2nd word...\r\n                        getNewLeftMostX( words[0] ) :   // ...estimate its expected location\r\n                        leftMostX;                      // otherwise we do not know where it shoud be...\r\n        let newRightMostX = rightMostX > rightThreshold ?    // if the right-most fixation lands right to the 2nd last word...\r\n                        getNewRightMostX( lastWord ) :       // ...estimate its expected location\r\n                        rightMostX;                          // otherwise we do not know where it shoud be...\r\n        const newRange = newRightMostX - newLeftMostX;\r\n        const oldRange = rightMostX - leftMostX;\r\n        const { scale, newXCorrection } = computeScale( newRange, oldRange );\r\n        log( 'scale', scale );\r\n\r\n        newLeftMostX -= newXCorrection;\r\n        newRightMostX += newXCorrection;\r\n\r\n        // Recalculate x's\r\n        for (let i = 0; i < fixations.length; i += 1) {\r\n            const fixation = fixations[i];\r\n            fixation._x = fixation.x;\r\n            fixation.x = newLeftMostX + scale * (fixation.x - leftMostX);\r\n        }\r\n    }\r\n}\r\n\r\n/**************\r\n    mapFixationsWithinLine\r\n**************/\r\n\r\nfunction getClosestWordID( fixation, words ) {\r\n    let minDist = Number.MAX_VALUE;\r\n    let minDistWordID = -1;\r\n\r\n    for (let i = 0; i < words.length; i += 1) {\r\n        const word = words[i];\r\n        const effectiveWordWidth = word.fixations || word.text.length <= settings.partialLengthMaxWordLength ?\r\n            settings.effectiveLengthFactor * word.width : word.width;\r\n\r\n        // BUGFIX: effectiveWordWidth =>> word.x + effectiveWordWidth\r\n        if (fixation.x >= word.x && fixation.x < (word.x + effectiveWordWidth)) {\r\n            minDistWordID = i;\r\n            minDist = 0;\r\n            break;\r\n        }\r\n        else {\r\n            const dist = Math.max( word.x - fixation.x, fixation.x - (word.x + effectiveWordWidth) );\r\n            if (dist < minDist) {\r\n                minDist = dist;\r\n                minDistWordID = i;\r\n            }\r\n        }\r\n    }\r\n\r\n    return minDistWordID;\r\n}\r\n\r\nfunction mapFixationsWithinLine( fixations, words ) {\r\n    log( '== mapping ==' );\r\n    for (let i = 0; i < fixations.length; i += 1) {\r\n        const fixation = fixations[i];\r\n\r\n        const closestWordID = getClosestWordID( fixation, words );\r\n        if (closestWordID < 0) {\r\n            log( `${fixation.id} => ---` );\r\n            continue;\r\n        }\r\n\r\n        const closestWord = words[ closestWordID ];\r\n        fixation.word = {\r\n            left: closestWord.x,\r\n            top: closestWord.y,\r\n            right: closestWord.x + closestWord.width,\r\n            bottom: closestWord.y + closestWord.height,\r\n            index: closestWordID,\r\n            text: closestWord.text,\r\n            id: closestWord.id\r\n        };\r\n\r\n        if (closestWord.fixations) {\r\n            closestWord.fixations.push( fixation );\r\n        }\r\n        else {\r\n            closestWord.fixations = [ fixation ];\r\n        }\r\n\r\n        log( `${fixation.id} => ${closestWord.id}` );\r\n    }\r\n}\r\n\r\n/***************\r\n    removeTransitions\r\n***************/\r\n\r\nfunction getPrevFixationOnLine( fixations, index ) {\r\n    let result = null;\r\n    for (; index > 0; index -= 1) {\r\n        const fix = fixations[ index ];\r\n        if (fix.line !== undefined) {\r\n            result = fix;\r\n            break;\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nfunction getLastChunkSaccade( fixations, index, direction ) {\r\n    let result = null;\r\n    for (; index > 0; index -= 1) {\r\n        const fix = fixations[ index ];\r\n        if (fix.line === undefined) {\r\n            continue;\r\n        }\r\n\r\n        const prevFix = getPrevFixationOnLine( fixations, index - 1 );\r\n        if (!prevFix) {\r\n            index = 0;\r\n            break;\r\n        }\r\n\r\n        if (direction < 0 ? fix.x < prevFix.x : fix.x >= prevFix.x) {\r\n            result = fix;\r\n            break;\r\n        }\r\n    }\r\n\r\n    return [ result, index ];\r\n}\r\n\r\nfunction removeFixation( fixations, id ) {\r\n    return fixations.filter( fixation => fixation.id !== id );\r\n}\r\n\r\nfunction removeTransitions( fixations, words ) {\r\n    let index = fixations.length - 1;\r\n\r\n    while (index) {\r\n        const [ firstProgressionFix, firstProgressionFixIndex ] = getLastChunkSaccade( fixations, index, -1 );\r\n        if (!firstProgressionFixIndex) {\r\n            break;\r\n        }\r\n\r\n        const [ lastProgressionFix, lastProgressionFixIndex ] = getLastChunkSaccade( fixations, firstProgressionFixIndex, 1 );\r\n        index = lastProgressionFixIndex;\r\n        if (!lastProgressionFix)  {\r\n            continue;\r\n        }\r\n\r\n        if (firstProgressionFix.line !== lastProgressionFix.line) {\r\n            for (let i = lastProgressionFixIndex + 1; i < firstProgressionFixIndex; i += 1) {\r\n                const fix = fixations[ i ];\r\n                if (fix.word) {\r\n                    const word = words[ fix.word.id ];\r\n                    if (word.fixations.length === 1) {\r\n                        delete word.fixations;\r\n                        log( 'removed @ word #', word.id );\r\n                    }\r\n                    else {\r\n                        word.fixations = removeFixation( word.fixations, fix.id );\r\n                        log( 'one removed @ word #', word.id );\r\n                    }\r\n\r\n                    delete fix.word;\r\n                    delete fix.line;\r\n\r\n                    log( 'removed @ fix #', fix.id );\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = WordMapper;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./wordMapper.js\n// module id = 10\n// module chunks = 0","'use strict';\r\n\r\nconst Settings = require('./settings');\r\n\r\nclass WordMapperSettings extends Settings {\r\n\tconstructor() {\r\n\t\tsuper( 'wordMapperSettings' );\r\n\t\tthis._wordCharSkipStart = 3;\r\n\t\tthis._wordCharSkipEnd = 6;\r\n\t\tthis._scalingDiffLimit = 0.9;\r\n\t\tthis._rescaleFixationX = true;\r\n\t\tthis._partialLengthMaxWordLength = 2;\r\n\t\tthis._effectiveLengthFactor = 0.7;\r\n\r\n\t\tsuper.load();\r\n\t}\r\n\r\n\tget wordCharSkipStart() { return this._wordCharSkipStart; }\r\n\tset wordCharSkipStart( value ) { this._wordCharSkipStart = value; }\r\n\tget wordCharSkipEnd() { return this._wordCharSkipEnd; }\r\n\tset wordCharSkipEnd( value ) { this._wordCharSkipEnd = value; }\r\n\tget scalingDiffLimit() { return this._scalingDiffLimit; }\r\n\tset scalingDiffLimit( value ) { this._scalingDiffLimit = value; }\r\n\tget rescaleFixationX() { return this._rescaleFixationX; }\r\n\tset rescaleFixationX( value ) { this._rescaleFixationX = value; }\r\n\tget partialLengthMaxWordLength() { return this._partialLengthMaxWordLength; }\r\n\tset partialLengthMaxWordLength( value ) { this._partialLengthMaxWordLength = value; }\r\n\tget effectiveLengthFactor() { return this._effectiveLengthFactor; }\r\n\tset effectiveLengthFactor( value ) { this._effectiveLengthFactor = value; }\r\n}\r\n\r\nmodule.exports = WordMapperSettings;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./wordMapperSettings.js\n// module id = 11\n// module chunks = 0"],"sourceRoot":""}